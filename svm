import os
import scipy.io
import numpy as np
import cv2
import matplotlib as mpl
import matplotlib.pyplot as plt
from IPython.display import display
import pandas as pd
from PIL import Image
from skimage.feature import hog
from skimage.color import rgb2grey
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
import inspect
from sklearn.metrics import roc_curve, auc
from PIL import ImageFilter
from skimage.feature import greycomatrix, greycoprops
import convsource
from sklearn.model_selection import KFold

fname='E:/paper/dataset/dataset_liver_bmodes_steatosis_assessment_IJCARS.mat'
data = scipy.io.loadmat(fname)
     
######################################################################
"""label1=[]
for k in range(34):
    label1.append(data['data'][0][k][1][0][0])

label2=[]
for l in range(10):
    label2.append(label1)
label2=np.array(label2)
label=label2.flatten()

label1=[]
for k in range(55):
    label1.append(data['data'][0][k][1][0][0])

label2=[]
for l in range(10):
    label2.append(label1)
label2=np.array(label2)
label=label2.flatten()
"""
label1=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 1, 1, 3, 1,
        1, 1, 3, 3, 2, 1, 1, 1, 2, 2, 3, 3, 3, 1, 3, 2, 3, 1, 1, 2, 2, 1, 1,
        1, 1, 1, 1, 1, 3, 2, 1, 1]
label2=[]
for l in range(10):
    label2.append(label1)
label2=np.array(label2)
label=label2.flatten()

p=100
kernel=np.zeros([p,p], dtype = int)
for i in range(p):
    for j in range(p):
        kernel[i,j]= (i-j)**2
            
#conv_img,kernel=convsource.conv(grey_image, padding=0,strides=1)

def create_features(img):
    # flatten three channel color image
    color_features = img.flatten()
    # convert image to greyscale
    grey_image = rgb2grey(img)
    # get HOG features from greyscale image
    hog_features = hog(grey_image, block_norm='L2-Hys',
                       pixels_per_cell=(16, 16))
    
    g= greycomatrix(img, [5], [0.,np.pi/4, np.pi/2.,3.*np.pi/4.], levels=256, 
                    normed=True, symmetric=True)
    
    #contrast= greycoprops(g,'contrast')
    convimg=convsource.convolution2d(grey_image,kernel,40,0)

    #print(np.shape(contrast))
    #conv_img= convolve2D(g, kernel1, padding=0, strides=1)
    #conv_img=convsource.conv(g, padding=0,strides=1)
    #print(np.shape(g))
    #print((conv_img))
    #conv_f= conv_img.flatten()
    flat_features = convimg.flatten()
    return flat_features
    

def create_feature_matrix():
     features_list = []
     for g in range(10):
         for img_id in range(55):
             img = data['data'][0][img_id][3][g]
             image_features = create_features(img)
             features_list.append(image_features)

     feature_matrix = np.array(features_list)
     return feature_matrix
feature_matrix = create_feature_matrix()
#print(feature_matrix)

ss = StandardScaler()
img_stand = ss.fit_transform(feature_matrix)

pca = PCA()
img_pca = pca.fit_transform(img_stand)
X = pd.DataFrame(img_pca)
y = pd.Series(label)

#X_train, X_test, y_train, y_test = train_test_split(X,
#                                                    y,
#                                                   test_size=.2,
 #                                                   random_state=1234123)

svm = SVC(kernel='linear', probability=True, random_state=42)

#svm.fit(X_train, y_train)


# generate predictions
#y_pred = svm.predict(X_test)

# calculate accuracy
#accuracy = accuracy_score(y_test, y_pred)
#print('Model accuracy is: ', accuracy)
"""
probabilities = svm.predict_proba(X_test)

# select the probabilities for label 1.0
y_proba = probabilities[:, 1]

# calculate false positive rate and true positive rate at different thresholds
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_proba, pos_label=1)

# calculate AUC
roc_auc = auc(false_positive_rate, true_positive_rate)

plt.title('Receiver Operating Characteristic')
# plot the false positive rate on the x axis and the true positive rate on the y axis
roc_plot = plt.plot(false_positive_rate,
                    true_positive_rate,
                    label='AUC = {:0.2f}'.format(roc_auc))

plt.legend(loc=0)
plt.plot([0,1], [0,1], ls='--')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()
"""
#Implementing cross validation
 
k = 4
kf = KFold(n_splits=k, random_state=None)
 
acc_score = []
 
for train_index , test_index in kf.split(X):
    X_train , X_test = X.iloc[train_index,:],X.iloc[test_index,:]
    y_train , y_test = y[train_index] , y[test_index]
     
    svm.fit(X_train,y_train)
    pred_values = svm.predict(X_test)
     
    acc = accuracy_score(pred_values , y_test)
    acc_score.append(acc)
     
avg_acc_score = sum(acc_score)/k
 
print('accuracy of each fold - {}'.format(acc_score))
print('Avg accuracy : {}'.format(avg_acc_score))
